from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, List, Optional, Sequence

import requests

from .rdkit_utils import canonical_smiles_from_smiles, mol_from_smiles, mol_formula


# Load isomer universes from surge-generated JSON file
def _load_surge_isomer_universes() -> Dict[str, Dict]:
    """Load isomer universes generated by surge tool."""
    isomer_json_path = Path(__file__).parent / "isomer_universes.json"

    if not isomer_json_path.exists():
        print(f"[WARNING] Isomer universe file not found: {isomer_json_path}")
        print("[WARNING] Run scripts/generate_isomer_universes.py to generate it")
        return {}

    try:
        with isomer_json_path.open('r') as f:
            data = json.load(f)

        # Validate and canonicalize all SMILES
        validated_universes = {}
        for formula, universe_data in data.items():
            smiles_list = universe_data['smiles']
            dbe = universe_data['dbe']

            clean = []
            seen = set()
            errors = []

            for s in smiles_list:
                mol = mol_from_smiles(s)
                if mol is None:
                    errors.append(f"Invalid SMILES: {s}")
                    continue

                # Check that the molecular formula matches
                actual_formula = mol_formula(mol)
                if actual_formula != formula:
                    errors.append(f"Formula mismatch: {s} is {actual_formula}, expected {formula}")
                    continue

                cs = canonical_smiles_from_smiles(s, isomeric=False)
                if cs and cs not in seen:
                    seen.add(cs)
                    clean.append(cs)

            if errors and len(errors) <= 3:  # Only print first few errors
                print(f"[WARNING] {formula}: {len(errors)} errors (showing first 3)")
                for err in errors[:3]:
                    print(f"  - {err}")

            validated_universes[formula] = {
                'smiles': sorted(clean),
                'count': len(clean),
                'dbe': dbe
            }

        print(f"[INFO] Loaded {len(validated_universes)} isomer universes from {isomer_json_path.name}")
        return validated_universes

    except Exception as e:
        print(f"[ERROR] Failed to load isomer universes: {e}")
        return {}


# Load surge-generated isomer universes
_SURGE_UNIVERSES = _load_surge_isomer_universes()

# Build BUILTIN_ISOMER_UNIVERSES dict from surge data (just SMILES lists for compatibility)
BUILTIN_ISOMER_UNIVERSES: Dict[str, List[str]] = {
    formula: universe_data['smiles']
    for formula, universe_data in _SURGE_UNIVERSES.items()
}


def fetch_pubchem_isomers_by_formula(
    formula: str,
    *,
    max_records: int = 5000,
    timeout_s: int = 60,
) -> List[str]:
    """
    Uses PubChem PUG REST:
      /compound/formula/{formula}/property/IsomericSMILES/JSON
    Returns raw IsomericSMILES strings (not canonicalized/deduped).
    """
    url = (
        "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/formula/"
        f"{formula}/property/IsomericSMILES/JSON"
    )
    params = {"MaxRecords": max_records}
    r = requests.get(url, params=params, timeout=timeout_s)
    r.raise_for_status()
    data = r.json()
    props = (
        data.get("PropertyTable", {})
        .get("Properties", [])
    )
    out: List[str] = []
    for row in props:
        smi = row.get("IsomericSMILES")
        if isinstance(smi, str) and smi.strip():
            out.append(smi.strip())
    return out


def canonicalize_and_filter_isomer_smiles(
    smiles_list: Sequence[str],
    *,
    required_formula: Optional[str] = None,
    drop_multicomponent: bool = True,
) -> List[str]:
    """
    Canonicalizes, de-duplicates, optionally filters by exact RDKit formula,
    and (optionally) removes multi-component SMILES containing '.'.
    """
    out = []
    seen = set()
    for s in smiles_list:
        if not isinstance(s, str) or not s.strip():
            continue
        s = s.strip()
        if drop_multicomponent and "." in s:
            continue
        mol = mol_from_smiles(s)
        if mol is None:
            continue
        if required_formula is not None and mol_formula(mol) != required_formula:
            continue
        cs = canonical_smiles_from_smiles(s, isomeric=False)
        if cs is None or cs in seen:
            continue
        seen.add(cs)
        out.append(cs)
    return sorted(out)


def get_isomer_universe(
    formula: str,
    *,
    source: str = "builtin",  # "builtin" or "pubchem"
    cache_dir: Path = Path("cache/isomers"),
    refresh: bool = False,
    pubchem_max_records: int = 5000,
) -> List[str]:
    """
    Returns a canonical, deduped isomer universe list for a given formula.
    If source='builtin', uses BUILTIN_ISOMER_UNIVERSES.
    If source='pubchem', fetches PubChem and caches.
    """
    formula = formula.strip()
    if source == "builtin":
        if formula not in BUILTIN_ISOMER_UNIVERSES:
            raise KeyError(f"No built-in universe for {formula}")
        return list(BUILTIN_ISOMER_UNIVERSES[formula])

    if source != "pubchem":
        raise ValueError("source must be 'builtin' or 'pubchem'")

    cache_dir.mkdir(parents=True, exist_ok=True)
    cache_path = cache_dir / f"pubchem_isomers_{formula}.json"

    if cache_path.exists() and not refresh:
        raw = json.loads(cache_path.read_text(encoding="utf-8"))
    else:
        raw = fetch_pubchem_isomers_by_formula(formula, max_records=pubchem_max_records)
        cache_path.write_text(json.dumps(raw, indent=2), encoding="utf-8")

    canon = canonicalize_and_filter_isomer_smiles(raw, required_formula=formula)
    canon_path = cache_dir / f"pubchem_isomers_{formula}_canonical.json"
    canon_path.write_text(json.dumps(canon, indent=2), encoding="utf-8")
    return canon
